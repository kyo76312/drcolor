<!--
本機開啟：存成 index.html 後直接用瀏覽器開啟即可
GitHub Pages：將此檔放到 repo 根目錄（index.html）即可直接執行
-->
<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>顏料排序by餅乾寶貝</title>
  <style>
    :root{
      --bg:#11151d;
      --panel:#1b2130;
      --panel2:#222a3d;
      --line:#303a55;
      --text:#eef3ff;
      --sub:#b7c3e5;
      --accent:#7fc8ff;
      --ok:#7af2b4;
      --warn:#ff97a5;
      --tube-w:52px;
      --tube-h:124px;
      --gap:7px;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:"Noto Sans TC","Microsoft JhengHei",sans-serif}
    body{overflow:hidden}
    .app{
      max-width:820px;
      height:100svh;
      margin:0 auto;
      padding:8px 10px max(10px, env(safe-area-inset-bottom));
      display:grid;
      grid-template-rows:auto auto 1fr;
      gap:8px;
      background:
        radial-gradient(700px 320px at 10% -5%, #2a3558 0%, transparent 55%),
        radial-gradient(620px 320px at 100% 110%, #1e3850 0%, transparent 52%),
        var(--bg);
    }

    .panel{
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg,var(--panel2),var(--panel));
    }

    .hud{padding:8px 10px}
    .title{margin:0 0 6px;font-size:18px;font-weight:800;letter-spacing:.4px}
    .stats{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
    .stat{
      border:1px solid var(--line);
      border-radius:10px;
      text-align:center;
      padding:6px 4px;
      background:#151b29;
    }
    .stat .k{font-size:11px;color:var(--sub)}
    .stat .v{font-size:14px;font-weight:700;margin-top:2px}

    .bar{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:6px;
    }
    button{
      height:42px;
      border-radius:10px;
      border:1px solid #374667;
      background:#1f2a44;
      color:var(--text);
      font-size:14px;
      font-weight:700;
      cursor:pointer;
    }
    button:active{transform:scale(.98)}
    button[disabled]{opacity:.5;cursor:not-allowed}

    .board{
      position:relative;
      overflow:hidden;
      padding:8px;
    }

    .grid{
      width:100%;
      height:100%;
      display:grid;
      justify-content:center;
      align-content:center;
      gap:var(--gap);
      touch-action:none;
    }

    .tube{
      width:var(--tube-w);
      height:var(--tube-h);
      border:none;
      padding:0;
      background:none;
      position:relative;
      transform-origin:50% 88%;
      transition:transform .2s cubic-bezier(.2,.8,.3,1.2), filter .2s, opacity .2s;
      cursor:pointer;
    }
    .tube.sel{transform:translateY(-6px) scale(1.04);z-index:8}
    .tube.can .shell{outline:2px solid #4ce4a055}
    .tube.no{opacity:.38}
    .tube.tiltL{transform:translateY(-6px) rotate(-24deg)}
    .tube.tiltR{transform:translateY(-6px) rotate(24deg)}
    .tube.shake{animation:shake .32s}
    @keyframes shake{
      25%{transform:translateX(-4px)}
      50%{transform:translateX(4px)}
      75%{transform:translateX(-3px)}
    }

    .shell{
      position:absolute;inset:0;
      border-radius:14px 14px 10px 10px;
      border:2px solid #c3deff66;
      background:linear-gradient(160deg,#ffffff22,#9cc4ff12);
      box-shadow:inset 0 0 0 1px #fff3,0 8px 16px #0007;
      overflow:hidden;
    }
    .shell::before{
      content:"";
      position:absolute;
      left:8%;top:8%;
      width:22%;height:72%;
      border-radius:999px;
      background:linear-gradient(180deg,#fff8,#fff0);
      pointer-events:none;
    }

    .cells{
      position:absolute;
      left:7px;right:7px;top:10px;bottom:7px;
      display:grid;
      gap:2px;
    }
    .cell{border-radius:4px;background:transparent;overflow:hidden}
    .cell.fill{
      box-shadow:inset 0 1px 0 #fff7, inset 0 -4px 8px #0004;
      animation:drop .22s ease;
    }
    @keyframes drop{
      from{transform:translateY(-5px);opacity:.2}
      to{transform:none;opacity:1}
    }

    .toast{
      position:absolute;
      left:50%;bottom:8px;
      transform:translateX(-50%);
      background:#0f1320d8;
      border:1px solid #3b4768;
      color:#eaf2ff;
      font-size:12px;
      font-weight:700;
      padding:6px 12px;
      border-radius:999px;
      opacity:0;
      pointer-events:none;
      transition:opacity .2s;
    }
    .toast.show{opacity:1}

    .modal{
      position:fixed;inset:0;
      display:none;
      place-items:center;
      background:#0009;
      z-index:40;
      padding:14px;
    }
    .modal.show{display:grid}
    .card{
      width:min(92vw,420px);
      border:1px solid #374667;
      border-radius:14px;
      background:linear-gradient(180deg,#1d2640,#141b2c);
      padding:12px;
    }
    .card h3{margin:0 0 10px;font-size:16px}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:8px 0}
    select,input[type="checkbox"]{font-size:14px}
    select{
      height:36px;
      border-radius:8px;
      border:1px solid #3d4c70;
      background:#0f182b;
      color:#eaf2ff;
      padding:0 8px;
    }
    .card .btns{
      display:grid;
      grid-template-columns:1fr;
      gap:8px;
      margin-top:10px;
    }

    .result-text{
      line-height:1.6;
      color:#edf3ff;
      font-size:15px;
      white-space:pre-line;
      min-height:54px;
    }

    #fx{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:30;
    }

    @media (max-width:380px){
      .title{font-size:16px}
      button{font-size:13px}
    }
  </style>
</head>
<body>
  <canvas id="fx" aria-hidden="true"></canvas>

  <div class="app">
    <section class="panel hud">
      <h1 class="title">顏料排序by餅乾寶貝</h1>
      <div class="stats">
        <div class="stat"><div class="k">關卡</div><div class="v" id="hudLevel">第1關/10</div></div>
        <div class="stat"><div class="k">本關剩餘</div><div class="v" id="hudRemain">03:00</div></div>
        <div class="stat"><div class="k">總時間</div><div class="v" id="hudTotal">00:00</div></div>
        <div class="stat"><div class="k">步數</div><div class="v" id="hudSteps">0</div></div>
      </div>
    </section>

    <section class="bar">
      <button id="undoBtn" type="button">上一步</button>
      <button id="settingBtn" type="button">設定</button>
    </section>

    <section class="panel board" id="board">
      <div class="grid" id="grid"></div>
      <div class="toast" id="toast"></div>
    </section>
  </div>

  <div class="modal" id="settingsModal">
    <div class="card">
      <h3>設定</h3>
      <div class="row"><span>音效</span><input id="soundChk" type="checkbox" checked /></div>
      <div class="row"><span>震動</span><input id="vibrateChk" type="checkbox" checked /></div>
      <div class="btns">
        <button id="closeSettingBtn" type="button">關閉</button>
      </div>
    </div>
  </div>

  <div class="modal" id="resultModal">
    <div class="card">
      <h3 id="resultTitle">結算</h3>
      <div class="result-text" id="resultText"></div>
      <div class="btns">
        <button id="resultActionBtn" type="button">從第1關重新開始</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      const STORAGE_KEY = "water_sort_linear_10_v1";
      const LEVEL_TIME = 180; // 3:00
      const TOTAL_LEVELS = 10;

      // 固定 10 關配置：tubeCount 8->16、capacity 4->8、至少2空管
      const LEVELS = [
        { tubeCount: 8,  capacity: 4, emptyTubes: 2, shuffleMoves: 150 },
        { tubeCount: 9,  capacity: 4, emptyTubes: 2, shuffleMoves: 190 },
        { tubeCount: 10, capacity: 5, emptyTubes: 2, shuffleMoves: 230 },
        { tubeCount: 11, capacity: 5, emptyTubes: 2, shuffleMoves: 280 },
        { tubeCount: 12, capacity: 6, emptyTubes: 2, shuffleMoves: 330 },
        { tubeCount: 13, capacity: 6, emptyTubes: 2, shuffleMoves: 390 },
        { tubeCount: 14, capacity: 7, emptyTubes: 2, shuffleMoves: 460 },
        { tubeCount: 15, capacity: 7, emptyTubes: 2, shuffleMoves: 540 },
        { tubeCount: 16, capacity: 8, emptyTubes: 2, shuffleMoves: 620 },
        { tubeCount: 16, capacity: 8, emptyTubes: 2, shuffleMoves: 720 }
      ];

      const PALETTE = [
        "#ff5f6d","#ff9f1c","#ffd166","#9ad94d",
        "#2ec4b6","#4cc9f0","#5b8cff","#9d7dff",
        "#f15bb5","#b08968","#7bdff2","#89e66b",
        "#ff7aa2","#55d6be","#f4b942","#7a9cff"
      ];

      const app = {
        state: {
          levelIndex: 0,
          tubes: [],
          tubeCount: 8,
          capacity: 4,
          emptyTubes: 2,
          steps: 0,
          selected: null,
          locked: false,
          solved: false,
          levelRemaining: LEVEL_TIME, // 秒
          totalElapsed: 0, // 秒
          status: "playing" // playing|transition|failed|cleared
        },
        settings: {
          sound: true,
          vibrate: true
        },
        undoStack: [],
        initialSnapshot: null,
        drag: null,
        audioCtx: null,
        rafId: null,
        lastTs: 0,
        saveAcc: 0,
        fx: { canvas: null, ctx: null, particles: [], running: false },
        el: {}
      };

      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

      function formatMMSS(seconds) {
        const s = Math.max(0, Math.ceil(seconds));
        const m = Math.floor(s / 60).toString().padStart(2, "0");
        const sec = (s % 60).toString().padStart(2, "0");
        return `${m}:${sec}`;
      }

      function formatCN(seconds) {
        const s = Math.max(0, Math.round(seconds));
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${m}分${sec}秒`;
      }

      function deepCopyTubes(tubes) {
        return tubes.map(t => t.slice());
      }

      function vibrate(ms = 12) {
        if (!app.settings.vibrate || !navigator.vibrate) return;
        navigator.vibrate(ms);
      }

      function showToast(msg) {
        const t = app.el.toast;
        t.textContent = msg;
        t.classList.add("show");
        clearTimeout(showToast._id);
        showToast._id = setTimeout(() => t.classList.remove("show"), 1000);
      }

      function lighten(hex, p) {
        const n = parseInt(hex.slice(1), 16);
        const r = n >> 16;
        const g = (n >> 8) & 255;
        const b = n & 255;
        const f = (x) => Math.round(x + (255 - x) * (p / 100));
        return `rgb(${f(r)}, ${f(g)}, ${f(b)})`;
      }

      // ---------- Audio ----------
      function ensureAudio() {
        if (app.audioCtx) return;
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return;
        app.audioCtx = new Ctx();
      }

      async function unlockAudio() {
        ensureAudio();
        if (!app.audioCtx) return;
        if (app.audioCtx.state === "suspended") {
          try { await app.audioCtx.resume(); } catch (_) {}
        }
      }

      function beep({ freq = 440, dur = 0.08, type = "sine", gain = 0.045, sweep = null }) {
        if (!app.settings.sound || !app.audioCtx) return;
        const ctx = app.audioCtx;
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const g = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, now);
        if (sweep) osc.frequency.exponentialRampToValueAtTime(Math.max(50, sweep), now + dur);

        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(gain, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

        osc.connect(g).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + dur + 0.01);
      }

      function playSound(kind) {
        if (!app.settings.sound || !app.audioCtx) return;
        if (kind === "select") beep({ freq: 670, dur: 0.06, type: "triangle", gain: 0.035 });
        if (kind === "pour") beep({ freq: 420, dur: 0.13, type: "sine", gain: 0.04, sweep: 260 });
        if (kind === "invalid") beep({ freq: 170, dur: 0.08, type: "square", gain: 0.025 });
        if (kind === "win") {
          beep({ freq: 430, dur: 0.09, type: "triangle", gain: 0.04 });
          setTimeout(() => beep({ freq: 560, dur: 0.10, type: "triangle", gain: 0.04 }), 80);
          setTimeout(() => beep({ freq: 760, dur: 0.12, type: "triangle", gain: 0.045 }), 170);
        }
        if (kind === "fail") {
          beep({ freq: 220, dur: 0.12, type: "square", gain: 0.03, sweep: 140 });
        }
      }
      // ---------- Core Rules ----------
      function getTopRunLength(tube) {
        if (!tube.length) return 0;
        const top = tube[tube.length - 1];
        let run = 1;
        for (let i = tube.length - 2; i >= 0; i--) {
          if (tube[i] !== top) break;
          run++;
        }
        return run;
      }

      function canPourOn(tubes, capacity, fromIdx, toIdx) {
        if (fromIdx === toIdx) return null;
        const from = tubes[fromIdx];
        const to = tubes[toIdx];
        if (!from || !to || from.length === 0 || to.length >= capacity) return null;

        const color = from[from.length - 1];
        if (to.length > 0 && to[to.length - 1] !== color) return null;

        const run = getTopRunLength(from);
        const free = capacity - to.length;
        const amount = Math.min(run, free);
        if (amount <= 0) return null;

        return { from: fromIdx, to: toIdx, color, amount };
      }

      function canPour(fromIdx, toIdx) {
        return canPourOn(app.state.tubes, app.state.capacity, fromIdx, toIdx);
      }

      function doPourOn(tubes, capacity, fromIdx, toIdx) {
        const info = canPourOn(tubes, capacity, fromIdx, toIdx);
        if (!info) return null;
        for (let i = 0; i < info.amount; i++) {
          tubes[toIdx].push(tubes[fromIdx].pop());
        }
        return info;
      }

      function doPour(fromIdx, toIdx) {
        return doPourOn(app.state.tubes, app.state.capacity, fromIdx, toIdx);
      }

      function undoMove(move) {
        if (!move) return;
        for (let i = 0; i < move.amount; i++) {
          app.state.tubes[move.from].push(app.state.tubes[move.to].pop());
        }
      }

      function isSolved(state = app.state.tubes) {
        const cap = app.state.capacity;
        for (const tube of state) {
          if (tube.length === 0) continue;
          if (tube.length !== cap) return false;
          const c = tube[0];
          for (let i = 1; i < tube.length; i++) if (tube[i] !== c) return false;
        }
        return true;
      }

      function allLegalMoves(tubes, capacity) {
        const moves = [];
        for (let i = 0; i < tubes.length; i++) {
          for (let j = 0; j < tubes.length; j++) {
            const m = canPourOn(tubes, capacity, i, j);
            if (m) moves.push(m);
          }
        }
        return moves;
      }

      // 依關卡設定生成（保證可解：從完成盤面反向打亂）
      function generateLevel(levelIndex) {
        const cfg = LEVELS[levelIndex];
        const cap = cfg.capacity;
        const tubeCount = cfg.tubeCount;
        const empty = cfg.emptyTubes;
        const colorCount = tubeCount - empty;

        function buildSolved() {
          const tubes = [];
          for (let c = 0; c < colorCount; c++) tubes.push(Array(cap).fill(c));
          for (let i = 0; i < empty; i++) tubes.push([]);
          return tubes;
        }

        function topColor(t) { return t.length ? t[t.length - 1] : null; }

        function reverseUnpour(tubes) {
          const donors = [];
          for (let i = 0; i < tubes.length; i++) {
            if (getTopRunLength(tubes[i]) >= 2) donors.push(i);
          }
          if (!donors.length) return false;

          const from = pick(donors);
          const color = topColor(tubes[from]);
          const run = getTopRunLength(tubes[from]);

          const targets = [];
          for (let j = 0; j < tubes.length; j++) {
            if (j === from) continue;
            const to = tubes[j];
            if (to.length >= cap) continue;
            if (to.length === 0 || topColor(to) !== color) targets.push(j);
          }
          if (!targets.length) return false;

          const to = pick(targets);
          const free = cap - tubes[to].length;
          const maxAmount = Math.min(run - 1, free); // 保留至少1格，確保可逆
          if (maxAmount <= 0) return false;

          const amount = 1 + Math.floor(Math.random() * maxAmount);
          for (let k = 0; k < amount; k++) tubes[to].push(tubes[from].pop());
          return true;
        }

        for (let attempt = 0; attempt < 45; attempt++) {
          const tubes = buildSolved();
          let applied = 0;
          let guard = cfg.shuffleMoves * 30;
          while (applied < cfg.shuffleMoves && guard-- > 0) {
            if (reverseUnpour(tubes)) applied++;
          }
          if (!isSolved(tubes) && allLegalMoves(tubes, cap).length > 0) return tubes;
        }

        const fallback = buildSolved();
        for (let i = 0; i < 150; i++) {
          const _ = (function () {
            const donors = [];
            for (let d = 0; d < fallback.length; d++) if (getTopRunLength(fallback[d]) >= 2) donors.push(d);
            if (!donors.length) return false;
            const from = pick(donors);
            const color = fallback[from][fallback[from].length - 1];
            const run = getTopRunLength(fallback[from]);
            const targets = [];
            for (let j = 0; j < fallback.length; j++) {
              if (j === from) continue;
              if (fallback[j].length >= cap) continue;
              if (fallback[j].length === 0 || fallback[j][fallback[j].length - 1] !== color) targets.push(j);
            }
            if (!targets.length) return false;
            const to = pick(targets);
            const free = cap - fallback[to].length;
            const max = Math.min(run - 1, free);
            if (max <= 0) return false;
            const amount = 1 + Math.floor(Math.random() * max);
            for (let k = 0; k < amount; k++) fallback[to].push(fallback[from].pop());
            return true;
          })();
          void _;
        }
        return fallback;
      }

      // ---------- Render ----------
      function fitBoard() {
        const count = app.state.tubeCount;
        const rect = app.el.board.getBoundingClientRect();
        const W = Math.max(120, rect.width - 16);
        const H = Math.max(120, rect.height - 16);

        let best = { cols: 4, w: 40, h: 90, score: 0 };
        const minCols = 3;
        const maxCols = Math.min(8, count);

        for (let cols = minCols; cols <= maxCols; cols++) {
          const rows = Math.ceil(count / cols);
          const gap = 7;
          const wByWidth = (W - (cols - 1) * gap) / cols;
          const hByHeight = (H - (rows - 1) * gap) / rows;
          const w = Math.floor(Math.min(wByWidth, hByHeight / 2.25));
          const h = Math.floor(w * 2.25);
          if (w > best.score) best = { cols, w, h, score: w };
        }

        const tubeW = clamp(best.w, 34, 66);
        const tubeH = clamp(best.h, 84, 152);
        app.el.grid.style.setProperty("--tube-w", `${tubeW}px`);
        app.el.grid.style.setProperty("--tube-h", `${tubeH}px`);
        app.el.grid.style.gridTemplateColumns = `repeat(${best.cols}, var(--tube-w))`;
      }

      function tubeEl(idx) {
        return app.el.grid.querySelector(`.tube[data-idx="${idx}"]`);
      }

      function renderHud() {
        app.el.hudLevel.textContent = `第${app.state.levelIndex + 1}關/10`;
        app.el.hudRemain.textContent = formatMMSS(app.state.levelRemaining);
        app.el.hudTotal.textContent = formatMMSS(app.state.totalElapsed);
        app.el.hudSteps.textContent = String(app.state.steps);
        app.el.undoBtn.disabled = app.undoStack.length === 0 || app.state.locked || app.state.status !== "playing";
      }

      function renderBoard() {
        const { tubes, capacity, selected, locked } = app.state;
        const legalTargets = new Set();
        if (selected !== null) {
          for (let i = 0; i < tubes.length; i++) if (canPour(selected, i)) legalTargets.add(i);
        }

        app.el.grid.innerHTML = "";
        tubes.forEach((tube, idx) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = "tube";
          b.dataset.idx = String(idx);
          b.ariaDisabled = (locked || app.state.status !== "playing") ? "true" : "false";

          if (selected === idx) b.classList.add("sel");
          if (selected !== null && selected !== idx) b.classList.add(legalTargets.has(idx) ? "can" : "no");

          const shell = document.createElement("div");
          shell.className = "shell";

          const cells = document.createElement("div");
          cells.className = "cells";
          cells.style.gridTemplateRows = `repeat(${capacity}, 1fr)`;

          for (let r = capacity - 1; r >= 0; r--) {
            const cell = document.createElement("div");
            cell.className = "cell";
            const v = tube[r];
            if (v !== undefined) {
              cell.classList.add("fill");
              const base = PALETTE[v % PALETTE.length];
              cell.style.background = `linear-gradient(180deg, ${lighten(base, 18)}, ${base})`;
            }
            cells.appendChild(cell);
          }

          shell.appendChild(cells);
          b.appendChild(shell);
          bindTubePointerEvents(b);
          app.el.grid.appendChild(b);
        });

        fitBoard();
      }

      function render() {
        renderHud();
        renderBoard();
      }
      // ---------- Interaction ----------
      function invalidFeedback(targetIdx) {
        const el = tubeEl(targetIdx);
        if (el) {
          el.classList.add("shake");
          setTimeout(() => el.classList.remove("shake"), 340);
        }
        playSound("invalid");
        vibrate(20);
      }

      async function animatePour(fromIdx, toIdx) {
        const fromEl = tubeEl(fromIdx);
        const toEl = tubeEl(toIdx);
        if (!fromEl || !toEl) return null;

        const fr = fromEl.getBoundingClientRect();
        const tr = toEl.getBoundingClientRect();
        const dir = fr.left < tr.left ? "tiltR" : "tiltL";
        fromEl.classList.add("sel", dir);

        playSound("pour");
        vibrate(10);

        await sleep(180);
        const move = doPour(fromIdx, toIdx);
        render();
        await sleep(170);
        return move;
      }

      async function attemptPour(fromIdx, toIdx) {
        if (app.state.locked || app.state.status !== "playing") return;
        if (!canPour(fromIdx, toIdx)) {
          invalidFeedback(toIdx);
          return;
        }

        app.state.locked = true;
        const move = await animatePour(fromIdx, toIdx);

        if (move) {
          app.undoStack.push(move);
          app.state.steps++;
          app.state.selected = null;
          app.state.solved = isSolved();
          saveGame();
          if (app.state.solved) {
            await onLevelComplete();
            return;
          }
        }

        app.state.locked = false;
        render();
      }

      function bindTubePointerEvents(el) {
        el.addEventListener("pointerdown", async (e) => {
          if (app.state.locked || app.state.status !== "playing") return;
          await unlockAudio();

          const idx = Number(el.dataset.idx);
          app.drag = {
            pointerId: e.pointerId,
            originIdx: idx,
            hoverIdx: idx,
            startX: e.clientX,
            startY: e.clientY,
            active: false,
            justSelected: false
          };

          el.setPointerCapture(e.pointerId);

          if (app.state.selected === null) {
            app.state.selected = idx;
            app.drag.justSelected = true;
            playSound("select");
            vibrate(8);
            render();
          }
          e.preventDefault();
        });

        el.addEventListener("pointermove", (e) => {
          const d = app.drag;
          if (!d || d.pointerId !== e.pointerId || app.state.locked || app.state.status !== "playing") return;

          const dx = e.clientX - d.startX;
          const dy = e.clientY - d.startY;
          if (!d.active && Math.hypot(dx, dy) > 9 && app.state.selected === d.originIdx) d.active = true;
          if (!d.active) return;

          const target = document.elementFromPoint(e.clientX, e.clientY)?.closest(".tube");
          if (target) d.hoverIdx = Number(target.dataset.idx);
        });

        const onUp = async (e) => {
          const d = app.drag;
          if (!d || d.pointerId !== e.pointerId) return;
          const idx = Number(el.dataset.idx);

          if (d.active) {
            if (d.hoverIdx !== undefined && d.hoverIdx !== app.state.selected && canPour(app.state.selected, d.hoverIdx)) {
              await attemptPour(app.state.selected, d.hoverIdx);
            } else if (d.hoverIdx !== undefined && d.hoverIdx !== app.state.selected) {
              invalidFeedback(d.hoverIdx);
            }
          } else {
            if (app.state.selected === idx) {
              if (!d.justSelected) {
                app.state.selected = null;
                render();
              }
            } else if (app.state.selected !== null) {
              await attemptPour(app.state.selected, idx);
            } else {
              app.state.selected = idx;
              playSound("select");
              vibrate(8);
              render();
            }
          }

          app.drag = null;
        };

        el.addEventListener("pointerup", onUp);
        el.addEventListener("pointercancel", onUp);
      }

      // ---------- Level Flow ----------
      function showResult({ title, text, showButton, buttonText }) {
        app.el.resultTitle.textContent = title;
        app.el.resultText.textContent = text;
        app.el.resultActionBtn.style.display = showButton ? "block" : "none";
        if (buttonText) app.el.resultActionBtn.textContent = buttonText;
        app.el.resultModal.classList.add("show");
      }

      function hideResult() {
        app.el.resultModal.classList.remove("show");
      }

      function startLevel(levelIndex, loadedData = null) {
        const cfg = LEVELS[levelIndex];
        app.state.levelIndex = levelIndex;
        app.state.tubeCount = cfg.tubeCount;
        app.state.capacity = cfg.capacity;
        app.state.emptyTubes = cfg.emptyTubes;
        app.state.selected = null;
        app.state.locked = false;
        app.state.solved = false;
        app.state.status = "playing";

        if (loadedData) {
          app.state.tubes = loadedData.tubes.map(t => t.slice(0, cfg.capacity));
          app.state.levelRemaining = clamp(loadedData.levelRemaining, 0, LEVEL_TIME);
          app.state.totalElapsed = Math.max(0, loadedData.totalElapsed);
          app.state.steps = Math.max(0, loadedData.steps);
          app.undoStack = Array.isArray(loadedData.undoStack) ? loadedData.undoStack : [];
        } else {
          app.state.tubes = generateLevel(levelIndex);
          app.state.levelRemaining = LEVEL_TIME;
          app.state.steps = 0;
          app.undoStack = [];
        }

        app.initialSnapshot = deepCopyTubes(app.state.tubes);
        saveGame();
        render();
      }

      function restartFromLevel1() {
        hideResult();
        app.state.totalElapsed = 0;
        app.undoStack = [];
        startLevel(0, null);
      }

      async function onLevelComplete() {
        app.state.status = "transition";
        app.state.locked = true;
        const levelUsed = LEVEL_TIME - app.state.levelRemaining;

        playSound("win");
        vibrate(36);
        launchParticles();

        showResult({
          title: "過關",
          text: `完成第${app.state.levelIndex + 1}關，使用時間${formatCN(levelUsed)}`,
          showButton: false
        });

        saveGame();

        if (app.state.levelIndex < TOTAL_LEVELS - 1) {
          setTimeout(() => {
            hideResult();
            startLevel(app.state.levelIndex + 1, null);
          }, 1500);
        } else {
          app.state.status = "cleared";
          showResult({
            title: "通關",
            text: `恭喜通關！總時間${formatCN(app.state.totalElapsed)}`,
            showButton: true,
            buttonText: "從第1關重新開始"
          });
          localStorage.removeItem(STORAGE_KEY);
        }
      }

      function onTimeUp() {
        if (app.state.status !== "playing") return;
        app.state.status = "failed";
        app.state.locked = true;
        app.state.levelRemaining = 0;
        renderHud();
        playSound("fail");
        vibrate(40);
        launchParticles(true);

        showResult({
          title: "挑戰失敗",
          text: `時間到！你總共花了${formatCN(app.state.totalElapsed)}，最終在第${app.state.levelIndex + 1}關失敗`,
          showButton: true,
          buttonText: "從第1關重新開始"
        });

        localStorage.removeItem(STORAGE_KEY);
      }

      // ---------- Save / Load ----------
      function saveGame() {
        const data = {
          v: 1,
          state: {
            levelIndex: app.state.levelIndex,
            tubes: app.state.tubes,
            levelRemaining: app.state.levelRemaining,
            totalElapsed: app.state.totalElapsed,
            steps: app.state.steps
          },
          undoStack: app.undoStack,
          settings: app.settings
        };
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch (_) {}
      }

      function loadGame() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return false;
          const data = JSON.parse(raw);
          if (!data || data.v !== 1) return false;
          if (!data.state || !Array.isArray(data.state.tubes)) return false;

          const idx = clamp(Number(data.state.levelIndex) || 0, 0, TOTAL_LEVELS - 1);
          app.settings.sound = data.settings?.sound !== false;
          app.settings.vibrate = data.settings?.vibrate !== false;

          startLevel(idx, {
            tubes: data.state.tubes,
            levelRemaining: Number(data.state.levelRemaining) || LEVEL_TIME,
            totalElapsed: Number(data.state.totalElapsed) || 0,
            steps: Number(data.state.steps) || 0,
            undoStack: Array.isArray(data.undoStack) ? data.undoStack : []
          });
          return true;
        } catch (_) {
          return false;
        }
      }

      // ---------- FX ----------
      function initFx() {
        app.fx.canvas = app.el.fx;
        app.fx.ctx = app.fx.canvas.getContext("2d");
        const resize = () => {
          app.fx.canvas.width = window.innerWidth * devicePixelRatio;
          app.fx.canvas.height = window.innerHeight * devicePixelRatio;
          app.fx.canvas.style.width = window.innerWidth + "px";
          app.fx.canvas.style.height = window.innerHeight + "px";
          app.fx.ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
          fitBoard();
        };
        window.addEventListener("resize", resize);
        resize();
      }

      function launchParticles(isFail = false) {
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight * 0.34;
        for (let i = 0; i < 95; i++) {
          const a = Math.random() * Math.PI * 2;
          const sp = 1.5 + Math.random() * 3;
          app.fx.particles.push({
            x: cx + (Math.random() - 0.5) * 90,
            y: cy + (Math.random() - 0.5) * 50,
            vx: Math.cos(a) * sp,
            vy: Math.sin(a) * sp - 2.4,
            life: 70 + Math.random() * 45,
            color: isFail ? "#ff8a94" : PALETTE[Math.floor(Math.random() * PALETTE.length)],
            size: 2 + Math.random() * 3.6
          });
        }
        if (!app.fx.running) runFx();
      }

      function runFx() {
        app.fx.running = true;
        const ctx = app.fx.ctx;
        const frame = () => {
          ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
          app.fx.particles = app.fx.particles.filter(p => p.life > 0);
          for (const p of app.fx.particles) {
            p.life--;
            p.vy += 0.05;
            p.x += p.vx;
            p.y += p.vy;
            ctx.globalAlpha = Math.max(0, p.life / 110);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          if (app.fx.particles.length) requestAnimationFrame(frame);
          else app.fx.running = false;
        };
        requestAnimationFrame(frame);
      }

      // ---------- Timer ----------
      function gameLoop(ts) {
        if (!app.lastTs) app.lastTs = ts;
        const dt = Math.min(0.05, (ts - app.lastTs) / 1000);
        app.lastTs = ts;

        if (app.state.status === "playing") {
          app.state.levelRemaining -= dt;
          app.state.totalElapsed += dt;
          if (app.state.levelRemaining <= 0) {
            app.state.levelRemaining = 0;
            onTimeUp();
          }
          renderHud();

          app.saveAcc += dt;
          if (app.saveAcc >= 1) {
            app.saveAcc = 0;
            saveGame();
          }
        }

        app.rafId = requestAnimationFrame(gameLoop);
      }

      // ---------- Init ----------
      function bindUI() {
        app.el = {
          board: document.getElementById("board"),
          grid: document.getElementById("grid"),
          toast: document.getElementById("toast"),

          hudLevel: document.getElementById("hudLevel"),
          hudRemain: document.getElementById("hudRemain"),
          hudTotal: document.getElementById("hudTotal"),
          hudSteps: document.getElementById("hudSteps"),

          undoBtn: document.getElementById("undoBtn"),
          settingBtn: document.getElementById("settingBtn"),

          settingsModal: document.getElementById("settingsModal"),
          soundChk: document.getElementById("soundChk"),
          vibrateChk: document.getElementById("vibrateChk"),
          closeSettingBtn: document.getElementById("closeSettingBtn"),

          resultModal: document.getElementById("resultModal"),
          resultTitle: document.getElementById("resultTitle"),
          resultText: document.getElementById("resultText"),
          resultActionBtn: document.getElementById("resultActionBtn"),

          fx: document.getElementById("fx")
        };

        app.el.undoBtn.addEventListener("click", () => {
          if (app.state.locked || app.state.status !== "playing" || !app.undoStack.length) return;
          const mv = app.undoStack.pop();
          undoMove(mv);
          app.state.steps = Math.max(0, app.state.steps - 1);
          app.state.selected = null;
          app.state.solved = false;
          playSound("select");
          saveGame();
          render();
        });

        app.el.settingBtn.addEventListener("click", () => {
          app.el.settingsModal.classList.add("show");
        });

        app.el.closeSettingBtn.addEventListener("click", () => {
          app.el.settingsModal.classList.remove("show");
          saveGame();
        });

        app.el.settingsModal.addEventListener("click", (e) => {
          if (e.target === app.el.settingsModal) app.el.settingsModal.classList.remove("show");
        });

        app.el.soundChk.addEventListener("change", () => {
          app.settings.sound = app.el.soundChk.checked;
          saveGame();
        });

        app.el.vibrateChk.addEventListener("change", () => {
          app.settings.vibrate = app.el.vibrateChk.checked;
          saveGame();
        });

        app.el.resultActionBtn.addEventListener("click", () => {
          restartFromLevel1();
        });

        document.addEventListener("pointerdown", unlockAudio, { passive: true });
      }

      function init() {
        bindUI();
        initFx();

        const hasSave = loadGame();
        if (!hasSave) {
          app.state.totalElapsed = 0;
          startLevel(0, null);
        }

        app.el.soundChk.checked = app.settings.sound;
        app.el.vibrateChk.checked = app.settings.vibrate;
        render();

        app.lastTs = 0;
        cancelAnimationFrame(app.rafId);
        app.rafId = requestAnimationFrame(gameLoop);

        showToast("依序挑戰第1~10關");
      }

      init();

      // 對外保留函式名稱
      window.canPour = canPour;
      window.getTopRunLength = getTopRunLength;
      window.doPour = doPour;
      window.undoMove = undoMove;
      window.isSolved = isSolved;
      window.generateLevel = generateLevel;
    })();
  </script>
</body>
</html>
