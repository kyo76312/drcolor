<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>水排序 Water Sort</title>
  <style>
    :root{
      --bg:#14171e;
      --panel:#1c2130;
      --panel2:#232a3d;
      --text:#f1f5ff;
      --sub:#b9c4e3;
      --accent:#7cc4ff;
      --ok:#7df2b4;
      --warn:#ff9aa3;
      --tube-w:52px;
      --tube-h:124px;
      --gap:8px;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:"Noto Sans TC","Microsoft JhengHei",sans-serif}
    body{overflow:hidden}
    .app{
      height:100svh;
      max-width:820px;
      margin:0 auto;
      display:grid;
      grid-template-rows:auto auto 1fr;
      gap:8px;
      padding:8px 10px max(10px,env(safe-area-inset-bottom));
      background:
        radial-gradient(600px 280px at 20% -5%, #2b3559 0%, transparent 55%),
        radial-gradient(500px 280px at 100% 110%, #243c51 0%, transparent 50%),
        var(--bg);
    }
    .top{
      background:linear-gradient(180deg,var(--panel2),var(--panel));
      border:1px solid #2a3350;
      border-radius:14px;
      padding:8px 10px;
    }
    .title{font-size:18px;font-weight:800;letter-spacing:.4px;margin:0 0 6px}
    .stats{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
    .stat{
      border:1px solid #2e3858;
      border-radius:10px;
      padding:5px 4px;
      text-align:center;
      background:#171d2b;
    }
    .stat .k{font-size:11px;color:var(--sub)}
    .stat .v{font-size:14px;font-weight:700;margin-top:2px}
    .bar{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:6px;
    }
    button{
      height:42px;
      border-radius:10px;
      border:1px solid #344064;
      background:#202a43;
      color:var(--text);
      font-weight:700;
      font-size:14px;
      cursor:pointer;
    }
    button:active{transform:scale(.98)}
    .board{
      background:linear-gradient(180deg,var(--panel),#171b28);
      border:1px solid #2a3350;
      border-radius:14px;
      padding:8px;
      overflow:hidden;
      position:relative;
    }
    .grid{
      width:100%;
      height:100%;
      display:grid;
      justify-content:center;
      align-content:center;
      gap:var(--gap);
      touch-action:none;
    }
    .tube{
      width:var(--tube-w);
      height:var(--tube-h);
      border:none;
      padding:0;
      background:none;
      position:relative;
      transform-origin:50% 88%;
      transition:transform .22s cubic-bezier(.2,.8,.3,1.2), filter .2s;
      cursor:pointer;
    }
    .tube.sel{transform:translateY(-6px) scale(1.04); z-index:5}
    .tube.can .shell{outline:2px solid #4ee39a55}
    .tube.no{opacity:.38}
    .tube.tiltL{transform:translateY(-6px) rotate(-25deg)}
    .tube.tiltR{transform:translateY(-6px) rotate(25deg)}
    .tube.hintFrom .shell,.tube.hintTo .shell{animation:pulse .9s ease 2}
    @keyframes pulse{50%{box-shadow:0 0 0 2px #7cc4ff77,0 8px 18px #0008}}
    .tube.shake{animation:shake .32s}
    @keyframes shake{25%{transform:translateX(-4px)}50%{transform:translateX(4px)}75%{transform:translateX(-3px)}}

    .shell{
      position:absolute;inset:0;
      border-radius:14px 14px 10px 10px;
      border:2px solid #b8d8ff66;
      background:linear-gradient(155deg,#ffffff22,#9ec6ff10);
      box-shadow:inset 0 0 0 1px #fff3,0 8px 18px #0007;
      overflow:hidden;
    }
    .shell:before{
      content:"";
      position:absolute;left:8%;top:7%;width:22%;height:72%;
      border-radius:999px;background:linear-gradient(180deg,#fff8,#fff0);
      pointer-events:none;
    }
    .cells{
      position:absolute;left:7px;right:7px;top:10px;bottom:7px;
      display:grid;gap:2px;
    }
    .cell{border-radius:4px;background:transparent;overflow:hidden}
    .cell.fill{
      box-shadow:inset 0 1px 0 #fff7,inset 0 -4px 8px #0004;
      animation:drop .22s ease;
    }
    @keyframes drop{from{transform:translateY(-5px);opacity:.2}to{transform:none;opacity:1}}

    .toast{
      position:absolute;left:50%;bottom:8px;transform:translateX(-50%);
      background:#0f1320cc;color:#eaf2ff;border:1px solid #3a4769;
      padding:6px 12px;border-radius:999px;font-size:12px;opacity:0;transition:.2s;
      pointer-events:none
    }
    .toast.show{opacity:1}

    .modal{
      position:fixed;inset:0;display:none;place-items:center;
      background:#0008;z-index:99;padding:14px;
    }
    .modal.show{display:grid}
    .card{
      width:min(92vw,420px);
      background:linear-gradient(180deg,#1f2740,#161d2f);
      border:1px solid #344064;border-radius:14px;padding:12px;
    }
    .card h3{margin:0 0 10px;font-size:16px}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:8px 0}
    select,input[type="checkbox"]{font-size:14px}
    select{
      height:36px;border-radius:8px;border:1px solid #3a486e;background:#10182b;color:#eef4ff;padding:0 8px
    }
    .card .btns{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    #fx{position:fixed;inset:0;pointer-events:none;z-index:90}

    @media (max-width:380px){
      .title{font-size:16px}
      button{font-size:13px}
    }
  </style>
</head>
<body>
<canvas id="fx"></canvas>
<div class="app">
  <div class="top">
    <h1 class="title">水排序 Water Sort</h1>
    <div class="stats">
      <div class="stat"><div class="k">步數</div><div class="v" id="steps">0</div></div>
      <div class="stat"><div class="k">時間</div><div class="v" id="time">00:00</div></div>
      <div class="stat"><div class="k">難度</div><div class="v" id="diff">Normal</div></div>
      <div class="stat"><div class="k">關卡</div><div class="v" id="level">1</div></div>
    </div>
  </div>

  <div class="bar">
    <button id="newBtn">新遊戲</button>
    <button id="undoBtn">上一步</button>
    <button id="hintBtn">提示</button>
    <button id="setBtn">設定</button>
  </div>

  <div class="board" id="board">
    <div class="grid" id="grid"></div>
    <div class="toast" id="toast"></div>
  </div>
</div>

<div class="modal" id="modal">
  <div class="card">
    <h3>設定</h3>
    <div class="row"><span>難度</span><select id="diffSel"><option value="easy">Easy</option><option value="normal">Normal</option><option value="hard">Hard</option></select></div>
    <div class="row"><span>容量</span><select id="capSel"><option value="4">4 層</option><option value="5">5 層</option></select></div>
    <div class="row"><span>主題</span><select id="themeSel"><option value="dark">深色</option><option value="blue">藍色</option></select></div>
    <div class="row"><span>音效</span><input id="soundChk" type="checkbox" checked></div>
    <div class="row"><span>震動</span><input id="vibChk" type="checkbox" checked></div>
    <div class="btns">
      <button id="nextBtn">下一關</button>
      <button id="autoBtn">收尾</button>
      <button id="resetBtn">重置本關</button>
      <button id="closeBtn">關閉</button>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";
  const KEY = "water_sort_clean_v2";
  const PALETTE = ["#ff5f6d","#ff9f1c","#ffd166","#8ad85f","#2ec4b6","#4cc9f0","#5b8cff","#9d7dff","#f15bb5","#b08968","#7bdff2","#9ef01a"];
  const App = {
    state:{tubes:[],capacity:4,difficulty:"normal",level:1,steps:0,elapsed:0,selected:null,locked:false,solved:false},
    settings:{sound:true,vibrate:true,theme:"dark"},
    undo:[], initSnap:null, drag:null, hint:null, timer:null, ctx:null, fx:[], fxRun:false
  };
  const el = {
    grid:document.getElementById("grid"), board:document.getElementById("board"),
    steps:document.getElementById("steps"), time:document.getElementById("time"), diff:document.getElementById("diff"), level:document.getElementById("level"),
    newBtn:document.getElementById("newBtn"), undoBtn:document.getElementById("undoBtn"), hintBtn:document.getElementById("hintBtn"), setBtn:document.getElementById("setBtn"),
    modal:document.getElementById("modal"), closeBtn:document.getElementById("closeBtn"),
    diffSel:document.getElementById("diffSel"), capSel:document.getElementById("capSel"), themeSel:document.getElementById("themeSel"),
    soundChk:document.getElementById("soundChk"), vibChk:document.getElementById("vibChk"),
    nextBtn:document.getElementById("nextBtn"), autoBtn:document.getElementById("autoBtn"), resetBtn:document.getElementById("resetBtn"),
    toast:document.getElementById("toast"), fx:document.getElementById("fx")
  };

  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const pick = a => a[Math.floor(Math.random()*a.length)];
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const copyTubes = t => t.map(x=>x.slice());
  const fmt = s => `${String(Math.floor(s/60)).padStart(2,"0")}:${String(s%60).padStart(2,"0")}`;
  const toast = (m)=>{ el.toast.textContent=m; el.toast.classList.add("show"); clearTimeout(toast.t); toast.t=setTimeout(()=>el.toast.classList.remove("show"),1200); };
  const vib = (ms=12)=>{ if(App.settings.vibrate && navigator.vibrate) navigator.vibrate(ms); };

  function audioInit(){ if(App.ctx) return; const A=window.AudioContext||window.webkitAudioContext; if(A) App.ctx=new A(); }
  async function audioUnlock(){ audioInit(); if(App.ctx && App.ctx.state==="suspended"){ try{await App.ctx.resume();}catch(_){} } }
  function beep(f=480,d=0.08,t="sine",g=0.04,f2=0){
    if(!App.settings.sound||!App.ctx) return;
    const c=App.ctx,n=c.currentTime,o=c.createOscillator(),a=c.createGain();
    o.type=t;o.frequency.setValueAtTime(f,n); if(f2) o.frequency.exponentialRampToValueAtTime(Math.max(50,f2),n+d);
    a.gain.setValueAtTime(0.0001,n); a.gain.exponentialRampToValueAtTime(g,n+0.01); a.gain.exponentialRampToValueAtTime(0.0001,n+d);
    o.connect(a).connect(c.destination); o.start(n); o.stop(n+d+0.01);
  }
  const sfx = k => { if(k==="sel")beep(680,.06,"triangle",.035); if(k==="pour")beep(430,.13,"sine",.04,260); if(k==="bad")beep(170,.08,"square",.025); if(k==="win"){beep(420,.09);setTimeout(()=>beep(560,.1),80);setTimeout(()=>beep(740,.12),170);} };

  function getTopRunLength(tube){
    if(!tube.length) return 0;
    const c=tube[tube.length-1]; let n=1;
    for(let i=tube.length-2;i>=0;i--){ if(tube[i]!==c) break; n++; }
    return n;
  }
  function canPourOn(tubes,cap,from,to){
    if(from===to) return null;
    const a=tubes[from], b=tubes[to];
    if(!a?.length || b.length>=cap) return null;
    const color=a[a.length-1];
    if(b.length && b[b.length-1]!==color) return null;
    const amount=Math.min(getTopRunLength(a),cap-b.length);
    return amount>0?{from,to,color,amount}:null;
  }
  function canPour(from,to){ return canPourOn(App.state.tubes,App.state.capacity,from,to); }
  function doPourOn(tubes,cap,from,to){
    const m=canPourOn(tubes,cap,from,to); if(!m) return null;
    for(let i=0;i<m.amount;i++) tubes[to].push(tubes[from].pop());
    return m;
  }
  function doPour(from,to){ return doPourOn(App.state.tubes,App.state.capacity,from,to); }
  function undoMove(m){ for(let i=0;i<m.amount;i++) App.state.tubes[m.from].push(App.state.tubes[m.to].pop()); }
  function isSolved(state=App.state.tubes){
    const cap=App.state.capacity;
    for(const t of state){
      if(!t.length) continue;
      if(t.length!==cap) return false;
      for(let i=1;i<t.length;i++) if(t[i]!==t[0]) return false;
    }
    return true;
  }
  function legalMoves(tubes,cap){
    const m=[]; for(let i=0;i<tubes.length;i++) for(let j=0;j<tubes.length;j++){ const x=canPourOn(tubes,cap,i,j); if(x) m.push(x); }
    return m;
  }
  function diffCfg(d,l,cap){
    if(d==="easy") return {colors:clamp(4+Math.floor((l-1)/2),4,7), empties:3, shuffle:clamp(180+l*22+(cap-4)*70,180,700)};
    if(d==="hard") return {colors:clamp(7+Math.floor((l-1)/2),7,10), empties:2, shuffle:clamp(420+l*36+(cap-4)*110,420,1200)};
    return {colors:clamp(6+Math.floor((l-1)/2),6,9), empties:2, shuffle:clamp(300+l*28+(cap-4)*90,300,950)};
  }

  function generateLevel(difficulty){
    const cap=App.state.capacity, cfg=diffCfg(difficulty,App.state.level,cap), colors=Math.min(cfg.colors,PALETTE.length);
    const buildSolved=()=>{ const t=[]; for(let c=0;c<colors;c++) t.push(Array(cap).fill(c)); for(let i=0;i<cfg.empties;i++) t.push([]); return t; };
    const top=t=>t.length?t[t.length-1]:null;

    function reverseUnpour(tubes){
      const donors=[]; for(let i=0;i<tubes.length;i++) if(getTopRunLength(tubes[i])>=2) donors.push(i);
      if(!donors.length) return false;
      const from=pick(donors), col=top(tubes[from]), run=getTopRunLength(tubes[from]);
      const targets=[];
      for(let j=0;j<tubes.length;j++){
        if(j===from) continue;
        const to=tubes[j];
        if(to.length>=cap) continue;
        if(!to.length || top(to)!==col) targets.push(j);
      }
      if(!targets.length) return false;
      const to=pick(targets), free=cap-tubes[to].length, max=Math.min(run-1,free);
      if(max<=0) return false;
      const amount=1+Math.floor(Math.random()*max);
      for(let k=0;k<amount;k++) tubes[to].push(tubes[from].pop());
      return true;
    }

    for(let attempt=0;attempt<40;attempt++){
      const tubes=buildSolved();
      let n=0, guard=cfg.shuffle*30;
      while(n<cfg.shuffle && guard-->0){ if(reverseUnpour(tubes)) n++; }
      if(!isSolved(tubes) && legalMoves(tubes,cap).length) return tubes;
    }
    const fb=buildSolved(); for(let i=0;i<120;i++) reverseUnpour(fb); return fb;
  }

  function fitBoard(){
    const count=App.state.tubes.length;
    const rect=el.board.getBoundingClientRect();
    const W=rect.width-16, H=rect.height-16;
    let best={cols:4,w:42,h:100,score:0};
    const minCols=3, maxCols=Math.min(8,count);
    for(let cols=minCols;cols<=maxCols;cols++){
      const rows=Math.ceil(count/cols), gap=8;
      const wByW=(W-(cols-1)*gap)/cols;
      const hByH=(H-(rows-1)*gap)/rows;
      const w=Math.floor(Math.min(wByW,hByH/2.25));
      const h=Math.floor(w*2.25);
      if(w>best.score) best={cols,w,h,score:w};
    }
    const w=clamp(best.w,36,66), h=clamp(best.h,86,150);
    el.grid.style.setProperty("--tube-w",w+"px");
    el.grid.style.setProperty("--tube-h",h+"px");
    el.grid.style.gridTemplateColumns=`repeat(${best.cols}, var(--tube-w))`;
  }

  function tubeEl(i){ return el.grid.querySelector(`.tube[data-i="${i}"]`); }

  function paintCellColor(elm, color){
    elm.style.background = `linear-gradient(180deg, ${lighten(color,18)}, ${color})`;
  }
  function lighten(hex,p){
    const n=parseInt(hex.slice(1),16),r=n>>16,g=(n>>8)&255,b=n&255;
    const f=x=>Math.round(x+(255-x)*(p/100));
    return `rgb(${f(r)},${f(g)},${f(b)})`;
  }

  function render(){
    const s=App.state;
    el.steps.textContent=s.steps;
    el.time.textContent=fmt(s.elapsed);
    el.diff.textContent=s.difficulty[0].toUpperCase()+s.difficulty.slice(1);
    el.level.textContent=s.level;
    el.undoBtn.disabled=!App.undo.length || s.locked;

    const legal = new Set();
    if(s.selected!==null){ for(let i=0;i<s.tubes.length;i++) if(canPour(s.selected,i)) legal.add(i); }

    el.grid.innerHTML="";
    s.tubes.forEach((tube,idx)=>{
      const b=document.createElement("button");
      b.className="tube";
      b.dataset.i=idx;
      if(s.selected===idx) b.classList.add("sel");
      if(s.selected!==null && s.selected!==idx) b.classList.add(legal.has(idx)?"can":"no");
      if(App.hint && App.hint.from===idx) b.classList.add("hintFrom");
      if(App.hint && App.hint.to===idx) b.classList.add("hintTo");

      const shell=document.createElement("div"); shell.className="shell";
      const cells=document.createElement("div"); cells.className="cells";
      cells.style.gridTemplateRows=`repeat(${s.capacity},1fr)`;

      for(let r=s.capacity-1;r>=0;r--){
        const c=document.createElement("div"); c.className="cell";
        if(tube[r]!==undefined){ c.classList.add("fill"); paintCellColor(c,PALETTE[tube[r]%PALETTE.length]); }
        cells.appendChild(c);
      }
      shell.appendChild(cells); b.appendChild(shell); el.grid.appendChild(b);
      bindTubeEvents(b);
    });
    fitBoard();
  }

  function badFeedback(i){
    const t=tubeEl(i); if(t){ t.classList.add("shake"); setTimeout(()=>t.classList.remove("shake"),320); }
    sfx("bad"); vib(20);
  }

  async function animatePour(from,to){
    const a=tubeEl(from), b=tubeEl(to);
    if(!a||!b) return null;
    const dir=a.getBoundingClientRect().left < b.getBoundingClientRect().left ? "tiltR":"tiltL";
    a.classList.add(dir,"sel");
    sfx("pour"); vib(10);
    await sleep(170);
    const m=doPour(from,to);
    render();
    await sleep(180);
    return m;
  }

  async function attemptPour(from,to){
    if(App.state.locked) return;
    if(!canPour(from,to)){ badFeedback(to); return; }
    App.state.locked=true;
    const m=await animatePour(from,to);
    if(m){
      App.undo.push(m);
      App.state.steps++;
      App.state.selected=null;
      App.state.solved=isSolved();
      save();
      if(App.state.solved){ sfx("win"); vib(40); confetti(); toast("完成！可到設定按下一關"); }
    }
    App.state.locked=false;
    render();
  }

  function bindTubeEvents(node){
    node.addEventListener("pointerdown", async e=>{
      if(App.state.locked) return;
      await audioUnlock();
      const idx=Number(node.dataset.i);
      App.drag={id:e.pointerId,startX:e.clientX,startY:e.clientY,hover:idx,active:false,just:false};
      node.setPointerCapture(e.pointerId);

      if(App.state.selected===null){
        App.state.selected=idx; App.drag.just=true;
        sfx("sel"); vib(8); render();
      }
      e.preventDefault();
    });

    node.addEventListener("pointermove", e=>{
      const d=App.drag; if(!d || d.id!==e.pointerId || App.state.locked) return;
      if(!d.active && Math.hypot(e.clientX-d.startX,e.clientY-d.startY)>8) d.active=true;
      if(!d.active) return;
      const hit=document.elementFromPoint(e.clientX,e.clientY)?.closest(".tube");
      if(hit) d.hover=Number(hit.dataset.i);
    });

    const up = async e=>{
      const d=App.drag; if(!d || d.id!==e.pointerId) return;
      const idx=Number(node.dataset.i);

      if(d.active){
        if(d.hover!==undefined && d.hover!==App.state.selected && canPour(App.state.selected,d.hover)) await attemptPour(App.state.selected,d.hover);
        else if(d.hover!==undefined && d.hover!==App.state.selected) badFeedback(d.hover);
      } else {
        if(App.state.selected===idx){
          if(!d.just){ App.state.selected=null; render(); }
        } else if(App.state.selected!==null){
          await attemptPour(App.state.selected, idx);
        } else {
          App.state.selected=idx; sfx("sel"); vib(8); render();
        }
      }
      App.drag=null;
    };
    node.addEventListener("pointerup", up);
    node.addEventListener("pointercancel", up);
  }

  function findHint(){
    const moves=legalMoves(App.state.tubes,App.state.capacity);
    if(!moves.length) return null;
    moves.sort((a,b)=>{
      const ta=App.state.tubes[a.to], tb=App.state.tubes[b.to];
      const sa=App.state.tubes[a.from], sb=App.state.tubes[b.from];
      const A=a.amount + (ta.length?2:0) + (sa.every(x=>x===sa[0])?1:0);
      const B=b.amount + (tb.length?2:0) + (sb.every(x=>x===sb[0])?1:0);
      return B-A;
    });
    return moves[0];
  }

  function obviousMove(){
    const moves=legalMoves(App.state.tubes,App.state.capacity);
    let best=null,score=-1;
    for(const m of moves){
      const f=App.state.tubes[m.from], t=App.state.tubes[m.to];
      const mono=f.every(x=>x===f[0]), full=t.length+m.amount===App.state.capacity;
      const s=(mono?3:0)+(t.length?2:0)+(full?3:0)+m.amount;
      if(s>score){score=s;best=m;}
    }
    return score>=5?best:null;
  }

  async function autoFinish(){
    if(App.state.locked) return;
    let guard=80;
    while(guard-- > 0 && !App.state.solved){
      const m=obviousMove(); if(!m) break;
      await attemptPour(m.from,m.to); await sleep(70);
    }
  }

  function newGame(resetLevel=true){
    App.state.selected=null; App.state.steps=0; App.state.elapsed=0; App.state.solved=false; App.undo=[]; App.hint=null;
    if(resetLevel) App.state.level=1;
    App.state.tubes=generateLevel(App.state.difficulty);
    App.initSnap=copyTubes(App.state.tubes);
    save(); render();
  }
  function nextLevel(){
    App.state.level++; App.state.steps=0; App.state.elapsed=0; App.state.selected=null; App.state.solved=false; App.undo=[]; App.hint=null;
    App.state.tubes=generateLevel(App.state.difficulty);
    App.initSnap=copyTubes(App.state.tubes);
    save(); render();
  }
  function resetLevel(){
    if(!App.initSnap) return;
    App.state.tubes=copyTubes(App.initSnap);
    App.state.steps=0; App.state.elapsed=0; App.state.selected=null; App.state.solved=false; App.undo=[];
    save(); render(); toast("已重置本關");
  }

  function save(){
    try{
      localStorage.setItem(KEY, JSON.stringify({
        v:2, state:App.state, settings:App.settings, undo:App.undo, init:App.initSnap
      }));
    }catch(_){}
  }
  function load(){
    try{
      const raw=localStorage.getItem(KEY); if(!raw) return false;
      const d=JSON.parse(raw); if(!d||d.v!==2) return false;
      if(!Array.isArray(d.state?.tubes)) return false;
      App.state.capacity=d.state.capacity===5?5:4;
      App.state.difficulty=["easy","normal","hard"].includes(d.state.difficulty)?d.state.difficulty:"normal";
      App.state.level=Math.max(1,Number(d.state.level)||1);
      App.state.steps=Math.max(0,Number(d.state.steps)||0);
      App.state.elapsed=Math.max(0,Number(d.state.elapsed)||0);
      App.state.selected=null; App.state.locked=false; App.state.solved=!!d.state.solved;
      App.state.tubes=d.state.tubes.map(t=>t.slice(0,App.state.capacity));
      App.settings.sound=d.settings?.sound!==false;
      App.settings.vibrate=d.settings?.vibrate!==false;
      App.settings.theme=d.settings?.theme==="blue"?"blue":"dark";
      App.undo=Array.isArray(d.undo)?d.undo:[];
      App.initSnap=Array.isArray(d.init)?d.init.map(t=>t.slice()):copyTubes(App.state.tubes);
      return true;
    }catch(_){ return false; }
  }

  function applyTheme(){
    if(App.settings.theme==="blue"){
      document.documentElement.style.setProperty("--bg","#0f1728");
      document.documentElement.style.setProperty("--panel","#15243d");
      document.documentElement.style.setProperty("--panel2","#1a3155");
    }else{
      document.documentElement.style.setProperty("--bg","#14171e");
      document.documentElement.style.setProperty("--panel","#1c2130");
      document.documentElement.style.setProperty("--panel2","#232a3d");
    }
  }

  function confetti(){
    const c=el.fx, ctx=c.getContext("2d");
    const dpr=window.devicePixelRatio||1;
    c.width=innerWidth*dpr; c.height=innerHeight*dpr; c.style.width=innerWidth+"px"; c.style.height=innerHeight+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    for(let i=0;i<90;i++){
      const a=Math.random()*Math.PI*2, v=1.5+Math.random()*3;
      App.fx.push({x:innerWidth/2+(Math.random()-0.5)*80,y:innerHeight*0.3+(Math.random()-0.5)*40,vx:Math.cos(a)*v,vy:Math.sin(a)*v-2.4,life:70+Math.random()*40,size:2+Math.random()*3,col:PALETTE[Math.floor(Math.random()*PALETTE.length)]});
    }
    if(App.fxRun) return;
    App.fxRun=true;
    (function tick(){
      ctx.clearRect(0,0,innerWidth,innerHeight);
      App.fx=App.fx.filter(p=>p.life>0);
      for(const p of App.fx){
        p.life--; p.vy+=0.05; p.x+=p.vx; p.y+=p.vy;
        ctx.globalAlpha=Math.max(0,p.life/110);
        ctx.fillStyle=p.col; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
      if(App.fx.length) requestAnimationFrame(tick); else App.fxRun=false;
    })();
  }

  function bindUI(){
    el.newBtn.onclick=async()=>{ await audioUnlock(); newGame(true); };
    el.undoBtn.onclick=()=>{ if(App.state.locked||!App.undo.length) return; const m=App.undo.pop(); undoMove(m); App.state.steps=Math.max(0,App.state.steps-1); App.state.selected=null; App.state.solved=false; save(); render(); };
    el.hintBtn.onclick=()=>{
      if(App.state.locked) return;
      const h=findHint();
      if(!h){ toast("沒有可用提示"); sfx("bad"); return; }
      App.hint={from:h.from,to:h.to}; render(); sfx("sel"); vib(12); toast(`提示：${h.from+1} → ${h.to+1}`);
      setTimeout(()=>{App.hint=null; render();},1400);
    };
    el.setBtn.onclick=()=>{ el.modal.classList.add("show"); };
    el.closeBtn.onclick=()=>{ el.modal.classList.remove("show"); save(); };
    el.modal.addEventListener("click",e=>{ if(e.target===el.modal) el.modal.classList.remove("show"); });

    el.diffSel.onchange=()=>{ App.state.difficulty=el.diffSel.value; newGame(true); };
    el.capSel.onchange=()=>{ App.state.capacity=Number(el.capSel.value)===5?5:4; newGame(true); };
    el.themeSel.onchange=()=>{ App.settings.theme=el.themeSel.value; applyTheme(); save(); };
    el.soundChk.onchange=()=>{ App.settings.sound=el.soundChk.checked; save(); };
    el.vibChk.onchange=()=>{ App.settings.vibrate=el.vibChk.checked; save(); };
    el.nextBtn.onclick=()=>{ if(!App.state.solved){ toast("先完成本關"); return; } nextLevel(); };
    el.autoBtn.onclick=autoFinish;
    el.resetBtn.onclick=resetLevel;

    window.addEventListener("resize", fitBoard);
    document.addEventListener("pointerdown", audioUnlock, {passive:true});
  }

  function syncUI(){
    el.diffSel.value=App.state.difficulty;
    el.capSel.value=String(App.state.capacity);
    el.themeSel.value=App.settings.theme;
    el.soundChk.checked=App.settings.sound;
    el.vibChk.checked=App.settings.vibrate;
    applyTheme();
  }

  function startTimer(){
    clearInterval(App.timer);
    App.timer=setInterval(()=>{ if(!App.state.solved && !App.state.locked){ App.state.elapsed++; el.time.textContent=fmt(App.state.elapsed); if(App.state.elapsed%3===0) save(); }},1000);
  }

  function init(){
    bindUI();
    const ok=load();
    if(!ok){ App.state.difficulty="normal"; App.state.capacity=4; App.state.level=1; newGame(false); }
    syncUI();
    render();
    startTimer();
  }

  init();

  window.canPour=canPour;
  window.getTopRunLength=getTopRunLength;
  window.doPour=doPour;
  window.undoMove=undoMove;
  window.isSolved=isSolved;
  window.generateLevel=generateLevel;
})();
</script>
</body>
</html>
